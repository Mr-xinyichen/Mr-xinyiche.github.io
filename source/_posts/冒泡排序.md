---
layout: posts
title: 冒泡排序
date: 2020-03-09 20:41:00
updated: 2020-03-09 20:43:40
tags: 
categories: 
 - 算法
 - 算法入门
---
### 方法思考：
#### 1.逻辑：
	1.遍历数组
	
	2.从第一个元素开始比较相邻两个元素的大小
	
	3.若 a[i] > a[i+1] 就交换位置
	
	4.第一次循环结束后 a[a.length-1]处值为当前数组中的最大值
	
	5.开启第二次循环 
	6. ......
#### 2.那么需要循环的条件又是什么呢？
```java
根据上述逻辑分析得以下结论：
	1.需要遍历a.length次
	2.每次循环需要比较相邻数的大小
	3.满足条件得元素需要交换值
	4.经过一次遍历最高位不用参与下次遍历（因为它为最大）
	5.由4可得每次需要遍历的元素都会减少1 
		所以可以使用两层循环：
			第一层次控制遍历次数，
			第二层实现具体排序。
	6.循环退出条件为 变量>1 
```
### 实现：
```java
public class Bubble {

    /**
     * 用于排序
     */
    public static void sort(Comparable[] a){
        for(int i=a.length-1;i>1;i--){
            for(int j=0;j<i;j++){
                if(greater(a[j],a[j+1])){
                    exch(a,j,j+1);
                }
            }
        }
    }

    /**
     * 比较两个元素的大小
     * @param c1
     * @param c2
     * @return 返回最大值
     */
    public static boolean greater(Comparable c1, Comparable c2){
        return c1.compareTo(c2)>0;
    }

    /**
     * 交换两个元素的位置
     * @param a
     * @param i
     * @param j
     */
    public static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### 测试：    
```java
public static void main(String[] args){
    Integer[] a ={7,8,1,5,4,2,6,3};
    Bubble.sort(a);
    System.out.println(Arrays.toString(a));
}
```
#### 打印：
	[1, 2, 3, 4, 5, 6, 7, 8]
### 时间复杂度（最坏情况）：
	O(n^2)
