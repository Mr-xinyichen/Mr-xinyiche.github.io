---
layout: posts
title: 设计模式之创建者模式
date: 2020-04-29 17:24:00
updated: 2020-04-29 17:32:20
tags: 
categories: 
 - 总结
---
## 1.简单工厂模式：
```java
/**
 * @author  cxy
 *  简单工厂模式
 *  一个工厂类 XxxFactory，里面有一个静态方法，根据不同的参数，返回不同的实例对象
 */
public class SimpleFactoryPatternDemo {
    public static void main(String[] args) {
        ServantFactory.servantCall("saber");
        ServantFactory.servantCall("caster");
    }
}

/**
 * 接口
 */
interface Servant{}

/**
 * 实现类1
 */
class Saber implements Servant{
    public Saber(){
        System.out.println("I'm saber");
    }
}

/**
 * 实现类2
 */
class Caster implements Servant{
    public Caster(){
        System.out.println("I'm caster");
    }
}

/**
 * 工厂给予实现类的get方法
 *      根据不同的条件生成不同的实现类
 */
class ServantFactory{
    public static Servant servantCall(String type){
        if (type.equals("saber")){
           return new Saber();
        }else if (type.equals("caster")){
            return  new Caster();
        }else {
            return null;
        }
    }
}
```

### 打印：
	I'm saber
	I'm caster

## 2.普通工厂模式：
```java
/**
 * @author cxy
 *  普通工厂模式 接口实现
 */
public class OrdinaryFactoryPatternDemo {
    public static void main(String[] args) {
        // 多态 获取具体工厂对象
        FoodFactory factory = new ChineseFoodFactory();
        // 通过签名指定要创建的对象
        factory.makeFood("A");

        AmericanFoodFactory factory1 = new AmericanFoodFactory();
        factory1.makeFood("B");
    }
}
```


​	
```java
/**
 * 主工厂 提供子工厂的get方法
 *  返回一个具体的工厂
 */
interface FoodFactory {
    /**
     * 返回一个工厂
     * @param name
     * @return
     */
    Food makeFood(String name);
}

/**
 * 子工厂1 重写父工厂get方法
 *      按条件返回具体的类
 */
class ChineseFoodFactory implements FoodFactory {
    @Override
    public Food makeFood(String name) {
        if (name.equals("A")) {
            return new ChineseFoodA();
        } else if (name.equals("B")) {
            return new ChineseFoodB();
        } else {
            return null;
        }
    }
}

/**
 * 子工厂1 重写父工厂get方法
 *
 */
class AmericanFoodFactory implements FoodFactory {
    @Override
    public Food makeFood(String name) {
        if (name.equals("A")) {
            return new AmericanFoodA();
        } else if (name.equals("B")) {
            return new AmericanFoodB();
        } else {
            return null;
        }
    }
}

/**
 * 实体类总接口
 */
interface Food{}

class ChineseFoodA implements Food{
    public ChineseFoodA(){
        System.out.println("ChineseFoodA");
    }
}
class ChineseFoodB implements Food{
    public ChineseFoodB(){
        System.out.println("ChineseFoodB");
    }
}
class AmericanFoodA implements Food{
    public AmericanFoodA(){
        System.out.println("AmericanFoodA");
    }
}
class AmericanFoodB implements Food{
    public AmericanFoodB(){
        System.out.println("AmericanneseFoodB");
    }
}
```
### 打印：
```java
ChineseFoodA
AmericanneseFoodB	
```
## 3.抽象工厂模式：
```java
/**
 * @author  cxy
 *  抽象类工厂模式
 *          适用于产品族 解决两个产品配件兼容性问题
 *          总工厂 ->委托Intel生产->全Intel配件的电脑
 *          总工厂 ->委托Amd生产->全Amd配件的电脑
 */
public class AbstractFactoryPatternDemo {
    public static void main(String[] args) {
        //需求Intel电脑
        ComputerFactory intelFactory = new IntelFactory();
        System.out.println("intelFactory:");
        intelFactory.makeCpu();
        intelFactory.makeMainBoard();
        intelFactory.makeHardDisk();
        System.out.println("-----------------------------");
        //需求Amd电脑
        ComputerFactory amdFactory = new AmdFactory();
        System.out.println("intelFactory:");
        amdFactory.makeCpu();
        amdFactory.makeMainBoard();
        amdFactory.makeHardDisk();
    }
}

/**
 * 抽象电脑工厂 为消费者生产电脑
 *  具体的电脑配件由各自工厂负责生产
 */
abstract class ComputerFactory{
    /**
     * 生产cpu
     * @return
     */
    abstract Cpu makeCpu();

    /**
     * 生成主板
     * @return
     */
    abstract MainBoard makeMainBoard();

    /**
     * 生产硬盘
     * @return
     */
    abstract HardDisk makeHardDisk();
}

interface Cpu{}
interface MainBoard{}
interface HardDisk{}
class IntelCpu implements Cpu{
    public IntelCpu() {
        System.out.println("IntelCpu");
    }
}
class IntelMainBoard implements MainBoard{
    public IntelMainBoard() {
        System.out.println("IntelMainBoard");
    }
}
class IntelHardDisk implements HardDisk{
    public IntelHardDisk() {
        System.out.println("IntelHardDisk");
    }
}

/**
 * 具体的配件类
 */
class AmdCpu implements Cpu{
    public AmdCpu() {
        System.out.println("AmdCpu");
    }
}
class AmdMainBoard implements MainBoard{
    public AmdMainBoard() {
        System.out.println("AmdMainBoard");
    }
}
class AmdHardDisk implements HardDisk{
    public AmdHardDisk() {
        System.out.println("AmdHardDisk");
    }
}

/**
 * 具体的Intel工厂类
 */
class IntelFactory extends ComputerFactory{

    @Override
    Cpu makeCpu() {
        return new IntelCpu();
    }

    @Override
    MainBoard makeMainBoard() {
        return new IntelMainBoard();
    }

    @Override
    HardDisk makeHardDisk() {
        return new IntelHardDisk();
    }
}

/**
 * 具体的Amd工厂类
 */
class AmdFactory extends ComputerFactory{
    @Override
    Cpu makeCpu() {
        return new AmdCpu();
    }

    @Override
    MainBoard makeMainBoard() {
        return new AmdMainBoard();
    }

    @Override
    HardDisk makeHardDisk() {
        return new AmdHardDisk();
    }
}
```
### 打印：
```java
intelFactory:
IntelCpu
IntelMainBoard
IntelHardDisk
-----------------------------
intelFactory:
AmdCpu
AmdMainBoard
AmdHardDisk
```
## 4.单例模式：

### 1）饿汉模式：

```java
/**
 * @author cxy
 *  饿汉模式
 */
public class HungryPatternDemo {
    public static void main(String[] args) {
        Date date = HungryPattern.getDate();
        System.out.println(date);
        //实例化方法会执行 不会再新建对象
        HungryPattern.getInstance();
    }
}

class HungryPattern{
    /**
     * 堵死构造器
     */
    private HungryPattern(){
        System.out.println("HungryPattern实例化。。。");
    };
    //因为是static修饰所以只会产生一个实例
    private static HungryPattern instance =new HungryPattern();

    public static HungryPattern getInstance(){
        //检测是否为单例
        System.out.println("实例构造器。。。");
        return instance;
    }

    /**
     * 调用此方法也会生产一个HungryPattern实例 （加载静态变量）
     * @return
     */
    public static Date getDate(){
        return new Date();
    }
}
```
### 打印：
```java
HungryPattern实例化。。。
Wed Apr 29 17:15:14 CST 2020
实例构造器。。。
```
### 2）饱汉模式：

```java
/**
 * @author cxy
 *  饱汉模式
 */
public class FullPatternDemo {
    public static void main(String[] args) {
         new Thread( ()-> FullPattern.getInstance(),"线程1").start();
         new Thread( ()-> FullPattern.getInstance(),"线程2").start();
    }
}

class FullPattern{
    /**
     * 堵死构造器
     */
    private FullPattern(){
        System.out.println("FullPattern实例化。。。");
    };
	//一定要使用volatile关键字
    private static volatile FullPattern instance = null;
    public static FullPattern getInstance(){
        if (instance == null){
            synchronized (FullPattern.class){
				// 这一次判断也是必须的，不然会有并发问题
                if (instance == null){
                    instance = new FullPattern();
                }
            }
        }
        return instance;
    }
}
```


​	
	
### 打印：
	FullPattern实例化。。。
### 推荐使用的方式：嵌套类
```java
/**
 * 推荐使用此种方式
 */
class Singleton {

    private Singleton() {
        System.out.println("Singleton");
    }

    /**
     * 使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性
     */
    private static class Holder {
        private static Singleton instance = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.instance;
    }
}
```
## 5.建造者模式 也就是所谓的xxx.build
```java
/**
 * @author cxy
 *      建造者模式
 */
public class BuilderPatternDemo {
    public static void main(String[] args) {
        User user = User.builder()
                .name("saber")
                .age(18).build();

        System.out.println(user);
    }
}

class User{
    private String name;
    private int age;

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /**
     * 私有化构造器
     * @param name
     * @param age
     */
    private User(String name,int age){
        this.name = name;
        this.age = age;
        System.out.println("User实例化。。。");
    }
    
    /**
     * 返回一个创建器直接链式调用
     * @return
     */
    public static UserBuilder builder(){
        return new UserBuilder();
    }

    public static class UserBuilder{
        //和User的属性一致 用于封装值
        private String name;
        private int age;

        /**
         * 私有化构造器
         */
        private UserBuilder(){}

        //设置值
        public UserBuilder name(String name){
            this.name = name;
            return this;
        }
        public UserBuilder age(int age){
            this.age = age;
            return this;
        }
        public User build(){
            //可以先进行参数校验 然后把值传递给User的构造器
            return new User(this.name,this.age);
        }
    }
}
```
### 打印：
```java
User实例化。。。
User{name='saber', age=18}
```
## 6.原型模式：浅拷贝
```java
Object 类中有一个 clone() 方法，它用于生成一个新的对象。
当然，如果我们要调用这个方法，java 要求我们的类必须先实现 Cloneable 接口
否则会抛出 CloneNotSupportedException 异常。

protected native Object clone() throws CloneNotSupportedException;
```

