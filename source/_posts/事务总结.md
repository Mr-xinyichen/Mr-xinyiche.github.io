---
layout: posts
title: 事务总结
date: 2020-03-18 21:50:00
updated: 2020-03-18 21:51:37
tags: 
categories: 
 - 总结
---
## 1、哪些东西是一定要回滚的、哪些即使出错了不必要回滚的。



## 2、事务的传播行为
propagation:当前方法的事务是否要和别人公用一个事务,以及如何传播下去（里面的方法如果用事务，是否和他公用一个事务）

    Propagation propagation() default Propagation.REQUIRED;
              
    REQUIRED:(必须):
    	Support a current transaction, create a new one if none exists.
    	如果以前有事务，就和之前的事务公用一个事务，没有就创建一个事务；
    REQUIRES_NEW（总是用新的事务）:
    	Create a new transaction, and suspend the current transaction if one exists.
    	创建一个新的事务，如果以前有事务，暂停前面的事务。
     
    SUPPORTS（支持）:
    	Support a current transaction, execute non-transactionally if none exists.
    	之前有事务，就以事务的方式运行，没有事务也可以；
     
    MANDATORY（强制）:没事务就报错
    	Support a current transaction, throw an exception if none exists
               一定要有事务，如果没事务就报错
     
    NOT_SUPPORTED（不支持）:
    	Execute non-transactionally, suspend the current transaction if one exists
    	不支持在事务内运行，如果已经有事务了，就挂起当前存在的事务
     
    NEVER（从不使用）:
    	 Execute non-transactionally, throw an exception if a transaction exists.
    	不支持在事务内运行，如果已经有事务了，抛异常
     
    NESTED:
    	Execute within a nested transaction if a current transaction exists,
    	开启一个子事务（MySQL不支持），需要支持还原点功能的数据库才行；
举例：
	一家人带着老王去旅游，开自己的车还是坐老王的车

```java
	Required：坐老王车
	Requires_new：一定得开车，开新的
	SUPPORTS：用车，有车就用，没车走路；
	MANDATORY：用车，没车就骂街。。。
	NOT_SUPPORTED：不支持用车。有车放那不用
	NEVER：从不用车，有车抛异常  
```
实际事务：

```java
Requires_new
 外事务{
	 A（）；Required; A

	 B（）;Requires_new B

	try{
		 C();Required; C
	}catch(Exception e){
	//c出异常？
	}

	D();Requires_new; D

    //给数据库存 --外事务
	// int i = 10/0;
 }

场景1：
	A方法出现了异常；由于异常机制导致代码停止，下面无法执行，数据库什么都没有
场景2：
	C方法出现异常；A回滚，B成功，C回滚，D无法执行，外无法执行
场景3：
	外成了后，int i = 10/0; B,D成功。A,C,外都执行了但是必须回滚
场景4：
	D炸；抛异常。外事务感知到异常。A,C回滚，外执行不到，D自己回滚，B成功
场景5：
	C用try-catch执行；C出了异常回滚，由于异常被捕获，外事务没有感知异常。A,B,D都成，C自己回滚

总结：
	传播行为过程中，只要Requires_new被执行过就一定成功，不管后面出不出问题。异常机制还是一样的，出现异常代码以后不执行。
Required只要感觉到异常就一定回滚。和外事务是什么传播行为无关。

传播行为总是来定义，当一个事务存在的时候，他内部的事务该怎么执行。
```
## 事务Spring中是怎么做的？
aop代理

```java
hahaServiceProxy.saveBaseInfo();

	A{
		A(){
		B(); //1,2,3
		C(); //4,5,6
		D(); //7,8,9
	}
}

自己类调用自己类里面的方法，就是一个复制粘贴，无法加上事务。

对象.方法()才能加上事务。
A{
	A(){
		hahaService.B();
		hahaService.C();
		hahaService.D();
	}
}

事务的问题：
	Service自己调用自己的方法，无法加上真正的自己内部调整的各个事务
	解决：
		//获取代理对象
      	xxxImpl proxy = (xxxImpl) AopContext.currentProxy();
		//用代理对象调用方法
	  	proxy.a();
```
## 隔离级别：
解决读写加锁问题的（数据底层的方案）。MYSQL默认可重复读（快照）	

* 读未提交
* 读已提交
* 可重复读
* 串行化

## 异常回滚策略
异常：

* 运行时异常（不受检查异常）
ArithmeticException ......
* 编译时异常（受检异常）
FileNotFound

###  运行的异常默认是一定回滚
###  编译时异常默认是不回滚的；
###  rollbackFor：指定哪些异常一定回滚的。

```java
//所有异常都回滚
@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = {Exception.class})
public void xxx(Param param) {
        
}
```