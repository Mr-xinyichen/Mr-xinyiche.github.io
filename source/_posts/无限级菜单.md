---
layout: posts
title: 无限级菜单
date: 2020-03-17 18:01:00
updated: 2020-03-17 18:05:43
tags: 
categories: 
 - Java
---
## MybatisPlus 递归实现无限级菜单
### 1.实体类

```java
@Data
public class PmsProductCategory implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

	...	
}
```
### 2.菜单封装类
```java
/**
 * 父级菜单本身是一个基本分类 只不过包含了一个子分类
 */
@Data
public class PmsProductCategoryWithChildrenItem extends PmsProductCategory  implements Serializable {

    private List<PmsProductCategory> children;

}
```
### 3.在mapper中定义方法
```java
public interface PmsProductCategoryMapper extends BaseMapper<PmsProductCategory> {

    //查询当前菜单及子菜单
    List<PmsProductCategoryWithChildrenItem> listCatelogWithChilder(Integer i);
}
```

### 4.修改xml文件
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.saber.gmall.pms.mapper.PmsProductCategoryMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.saber.gmall.pms.entity.PmsProductCategory">
        <id column="id" property="id" />
        <result column="parent_id" property="parentId" />
        <result column="name" property="name" />
        <result column="level" property="level" />
        <result column="product_count" property="productCount" />
        <result column="product_unit" property="productUnit" />
        <result column="nav_status" property="navStatus" />
        <result column="show_status" property="showStatus" />
        <result column="sort" property="sort" />
        <result column="icon" property="icon" />
        <result column="keywords" property="keywords" />
        <result column="description" property="description" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, parent_id, name, level, product_count, product_unit, nav_status, show_status, sort, icon, keywords, description
    </sql>
	<!-- 查询结果封装列 -->
    <resultMap id="ExtendResultMap" type="com.saber.gmall.vo.product.PmsProductCategoryWithChildrenItem"
    extends="BaseResultMap">
        <collection property="children" select="listCatelogWithChilder" column="id"></collection>
    </resultMap>

    <!-- List<PmsProductCategoryWithChildrenItem> listCatelogWithChilder(Integer i) -->
    <select id="listCatelogWithChilder" resultMap="ExtendResultMap">
        SELECT * FROM pms_product_category WHERE parent_id = # {i}
    </select>

</mapper>
```
可以看出底层不过是根据父id查询数据，关键在于结果封装列里**children属性**，它的数据来源为下一次以**本次结果集id字段**为条件再次查询，那么只要还存在子集就会一直查询下去，直到查出所有。

## 问题：
上述的方式的确可以封装多级菜单，但是每次都遇到查询很多次的sql，对服务器的资源消耗很大：

```cmd
2020-03-17 17:34:08.022 DEBUG 16620 --- [20800-thread-19] c.s.g.p.m.PmsProductMapper.selectPage    : ==>  Preparing: SELECT id,brand_id,product_category_id,feight_template_id,product_attribute_category_id,name,pic,product_sn,delete_status,publish_status,new_status,recommand_status,verify_status,sort,sale,price,promotion_price,gift_growth,gift_point,use_point_limit,sub_title,description,original_price,stock,low_stock,unit,weight,preview_status,service_ids,keywords,note,album_pics,detail_title,detail_desc,detail_html,detail_mobile_html,promotion_start_time,promotion_end_time,promotion_per_limit,promotion_type,brand_name,product_category_name FROM pms_product LIMIT 0,5 
2020-03-17 17:34:08.022 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ==> Parameters: 0(Integer)
2020-03-17 17:34:08.022 DEBUG 16620 --- [20800-thread-20] c.s.g.p.m.PmsBrandMapper.selectPage      : ==> Parameters: 
2020-03-17 17:34:08.022 DEBUG 16620 --- [20800-thread-19] c.s.g.p.m.PmsProductMapper.selectPage    : ==> Parameters: 
2020-03-17 17:34:08.024 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ====>  Preparing: SELECT * FROM pms_product_category WHERE parent_id = ? 
2020-03-17 17:34:08.025 DEBUG 16620 --- [20800-thread-20] c.s.g.p.m.PmsBrandMapper.selectPage      : <==      Total: 10
2020-03-17 17:34:08.025 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ====> Parameters: 1(Long)
2020-03-17 17:34:08.025 DEBUG 16620 --- [20800-thread-20] org.mybatis.spring.SqlSessionUtils       : Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@12924a24]
2020-03-17 17:34:08.027 DEBUG 16620 --- [20800-thread-19] c.s.g.p.m.PmsProductMapper.selectPage    : <==      Total: 5
2020-03-17 17:34:08.027 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ======>  Preparing: SELECT * FROM pms_product_category WHERE parent_id = ? 
2020-03-17 17:34:08.027 DEBUG 16620 --- [20800-thread-19] org.mybatis.spring.SqlSessionUtils       : Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@471384b3]
2020-03-17 17:34:08.027 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ======> Parameters: 7(Long)
2020-03-17 17:34:08.029 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ========>  Preparing: SELECT * FROM pms_product_category WHERE parent_id = ? 
2020-03-17 17:34:08.030 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ========> Parameters: 53(Long)
2020-03-17 17:34:08.032 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : <========      Total: 0
2020-03-17 17:34:08.033 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ========>  Preparing: SELECT * FROM pms_product_category WHERE parent_id = ? 
2020-03-17 17:34:08.034 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : ========> Parameters: 55(Long)
2020-03-17 17:34:08.035 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : <========      Total: 0
2020-03-17 17:34:08.036 DEBUG 16620 --- [20800-thread-21] c.s.g.p.m.P.listCatelogWithChilder       : <======      Total: 2
```

## 解决：
那么我们该如何去解决的？<br>
首先想到的就是使用一个容器比如HashMap把数据存储起来，下次查询先判断map里是否有该数据，有就直接获取，没有就查询并存储到容器<br><br>
但是这里也有一个问题，如果是单体项目这样肯定没问题；如果是分布式项目呢？

* 假设这个功能我部署到100服务器上，HashMap只能存在于当前服务器，那么由于负载均衡每个服务器都会被访问到，就需要存储100次数据

那么就利用redis缓存，为什么不用cookie呢，因为他有大小限制。
### 添加redis场景启动器
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```
### 配置redis
```properties
spring.redis.host=192.168.227.200
spring.redis.database=0
spring.redis.port=6379
```
### 导入RedisTemplate
```java
@Autowired
RedisTemplate<Object,Object> redisTemplate;
```
这里有个问题，我们存储的数据都是以对象的基础单位的，redis中存对象默认是使用序列化方式，而RedisTemplate默认使用jdk序列化

```java
public  void  redisTemplateObject(){
        PmsBrand pmsBrand = new PmsBrand();
        pmsBrand.setName("hello");
        redisTemplateObj.opsForValue().set("abc",pmsBrand );
        System.out.println("保存了对象");

        Object abc = redisTemplateObj.opsForValue().get("abc");
        System.out.println(abc);
    }
```
实际存储：

```java
//key:
\xAC\xED\x00\x05t\x00\x03abc

//value:
\xAC\xED\x00\x05sr\x00# com.saber.gmall.pms.entity.PmsBrand\x00\x00\x00\x00
\x00\x00\x00\x01\x02\x00\x0BL\x00\x06bigPict\x00\x12Ljava/lang/String;L\x00
\x0AbrandStoryq\x00~\x00\x01L\x00\x0DfactoryStatust\x00\x13Ljava/lang/Integer;L
\x00\x0BfirstLetterq\x00~\x00\x01L\x00\x02idt\x00\x10Ljava/lang/Long;L\x00
\x04logoq\x00~\x00\x01L\x00\x04nameq\x00~\x00\x01L\x00\x13productCommentCountq
\x00~\x00\x02L\x00\x0CproductCountq\x00~\x00\x02L\x00\x0AshowStatusq\x00~\x00
\x02L\x00\x04sortq\x00~\x00\x02xpppppppt\x00\x05hellopppp
```
首先是没有可读性,第二是如果有一天改用其他的语言(PHP)编写那么他将拿不到这个数据，所以要将数据序列成通用格式，比如json
### 配置RedisTemplate序列化规则
```java
@Configuration
public class PmsRedisConfig {

    @Bean("redisTemplate")
    public RedisTemplate<Object,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)
            throws UnknownHostException {
        RedisTemplate<Object,Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        //修改默认的序列化方式
        template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
        return template;
    }
}
```
### 最终业务
```java
public List<PmsProductCategoryWithChildrenItem> listCatelogWithChilder(Integer i) {
    //先查询缓存中是否有菜单
    Object cacheMenu = redisTemplate.opsForValue().get(SysCacheConstant.CATEGORY_MENU_XACHE_KEY);
    List<PmsProductCategoryWithChildrenItem> items;
    if (cacheMenu!=null){  //缓存里有 强转
        log.debug("菜单数据命中缓存...");
        items = (List<PmsProductCategoryWithChildrenItem>) cacheMenu;
    }else { //缓存里没有 查询数据库
        items = productCategoryMapper.listCatelogWithChilder(i);
        redisTemplate.opsForValue().set(SysCacheConstant.CATEGORY_MENU_XACHE_KEY,items);
    }
    return items;
}
```

## 测试：
第一次发送大sql查询数据库<br>
第二次命中缓存：

```java
2020-03-17 18:03:37.501 DEBUG 9252 --- [:20800-thread-2] o.s.d.redis.core.RedisConnectionUtils    : Closing Redis Connection.
2020-03-17 18:03:37.501 DEBUG 9252 --- [:20800-thread-2] .s.g.p.s.i.PmsProductCategoryServiceImpl : 菜单数据命中缓存...
```